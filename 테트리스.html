import React, { useState, useEffect, useRef } from 'react';

export default function BrickBreaker() {
  const canvasRef = useRef(null);
  const [gameStarted, setGameStarted] = useState(false);
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [gameOver, setGameOver] = useState(false);
  const [gameWon, setGameWon] = useState(false);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Game objects
    const paddle = {
      x: width / 2 - 50,
      y: height - 30,
      width: 100,
      height: 10,
      speed: 8
    };

    const ball = {
      x: width / 2,
      y: height / 2,
      radius: 8,
      dx: 4,
      dy: -4,
      speed: 4
    };

    // Create bricks
    const brickRowCount = 5;
    const brickColumnCount = 8;
    const brickWidth = 70;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 50;
    const brickOffsetLeft = 35;

    const bricks = [];
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
    
    for (let c = 0; c < brickColumnCount; c++) {
      bricks[c] = [];
      for (let r = 0; r < brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1, color: colors[r] };
      }
    }

    // Keyboard controls
    let rightPressed = false;
    let leftPressed = false;

    function keyDownHandler(e) {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = true;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = true;
      }
    }

    function keyUpHandler(e) {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = false;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = false;
      }
    }

    // Mouse/touch control
    function mouseMoveHandler(e) {
      const rect = canvas.getBoundingClientRect();
      const relativeX = e.clientX - rect.left;
      if (relativeX > 0 && relativeX < width) {
        paddle.x = relativeX - paddle.width / 2;
      }
    }

    document.addEventListener('keydown', keyDownHandler);
    document.addEventListener('keyup', keyUpHandler);
    canvas.addEventListener('mousemove', mouseMoveHandler);

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 5);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.roundRect(brickX, brickY, brickWidth, brickHeight, 4);
            ctx.fillStyle = bricks[c][r].color;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            if (
              ball.x > b.x &&
              ball.x < b.x + brickWidth &&
              ball.y > b.y &&
              ball.y < b.y + brickHeight
            ) {
              ball.dy = -ball.dy;
              b.status = 0;
              setScore(prev => prev + 10);
              
              // Check if all bricks are destroyed
              const allDestroyed = bricks.every(col => 
                col.every(brick => brick.status === 0)
              );
              if (allDestroyed) {
                setGameWon(true);
                setGameStarted(false);
              }
            }
          }
        }
      }
    }

    function draw() {
      if (!gameStarted || gameOver || gameWon) return;

      ctx.clearRect(0, 0, width, height);
      drawBricks();
      drawBall();
      drawPaddle();
      collisionDetection();

      // Ball collision with walls
      if (ball.x + ball.dx > width - ball.radius || ball.x + ball.dx < ball.radius) {
        ball.dx = -ball.dx;
      }
      if (ball.y + ball.dy < ball.radius) {
        ball.dy = -ball.dy;
      } else if (ball.y + ball.dy > height - ball.radius) {
        // Check paddle collision
        if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
          // Add spin based on where ball hits paddle
          const hitPos = (ball.x - paddle.x) / paddle.width;
          ball.dx = (hitPos - 0.5) * 8;
          ball.dy = -ball.dy;
        } else {
          // Lost a life
          setLives(prev => {
            const newLives = prev - 1;
            if (newLives === 0) {
              setGameOver(true);
              setGameStarted(false);
            }
            return newLives;
          });
          ball.x = width / 2;
          ball.y = height / 2;
          ball.dx = 4;
          ball.dy = -4;
          paddle.x = width / 2 - 50;
        }
      }

      // Move paddle
      if (rightPressed && paddle.x < width - paddle.width) {
        paddle.x += paddle.speed;
      } else if (leftPressed && paddle.x > 0) {
        paddle.x -= paddle.speed;
      }

      // Move ball
      ball.x += ball.dx;
      ball.y += ball.dy;

      requestAnimationFrame(draw);
    }

    if (gameStarted) {
      draw();
    }

    return () => {
      document.removeEventListener('keydown', keyDownHandler);
      document.removeEventListener('keyup', keyUpHandler);
      canvas.removeEventListener('mousemove', mouseMoveHandler);
    };
  }, [gameStarted, gameOver, gameWon]);

  const startGame = () => {
    setGameStarted(true);
    setGameOver(false);
    setGameWon(false);
    setScore(0);
    setLives(3);
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
      <div className="text-center mb-6">
        <h1 className="text-5xl font-bold text-white mb-2">ë²½ëŒê¹¨ê¸°</h1>
        <p className="text-blue-200 text-lg">í™”ì‚´í‘œ í‚¤ë‚˜ ë§ˆìš°ìŠ¤ë¡œ íŒ¨ë“¤ì„ ì›€ì§ì´ì„¸ìš”!</p>
      </div>

      <div className="bg-gray-900 p-6 rounded-2xl shadow-2xl">
        <div className="flex justify-between mb-4 text-white text-xl">
          <div className="bg-blue-600 px-6 py-2 rounded-lg">
            ì ìˆ˜: <span className="font-bold">{score}</span>
          </div>
          <div className="bg-red-600 px-6 py-2 rounded-lg">
            ìƒëª…: <span className="font-bold">{'â¤ï¸'.repeat(lives)}</span>
          </div>
        </div>

        <div className="relative">
          <canvas
            ref={canvasRef}
            width={640}
            height={480}
            className="bg-gray-800 rounded-lg border-4 border-gray-700"
          />
          
          {!gameStarted && !gameOver && !gameWon && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 rounded-lg">
              <button
                onClick={startGame}
                className="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-12 py-4 rounded-full text-2xl font-bold hover:from-green-600 hover:to-emerald-700 transform hover:scale-105 transition-all shadow-lg"
              >
                ê²Œì„ ì‹œì‘
              </button>
            </div>
          )}

          {gameOver && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 rounded-lg">
              <div className="text-center">
                <h2 className="text-4xl font-bold text-red-500 mb-4">ê²Œì„ ì˜¤ë²„!</h2>
                <p className="text-white text-2xl mb-6">ìµœì¢… ì ìˆ˜: {score}</p>
                <button
                  onClick={startGame}
                  className="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-10 py-3 rounded-full text-xl font-bold hover:from-blue-600 hover:to-purple-700 transform hover:scale-105 transition-all"
                >
                  ë‹¤ì‹œ ì‹œì‘
                </button>
              </div>
            </div>
          )}

          {gameWon && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 rounded-lg">
              <div className="text-center">
                <h2 className="text-4xl font-bold text-yellow-400 mb-4">ğŸ‰ ìŠ¹ë¦¬! ğŸ‰</h2>
                <p className="text-white text-2xl mb-6">ìµœì¢… ì ìˆ˜: {score}</p>
                <button
                  onClick={startGame}
                  className="bg-gradient-to-r from-yellow-500 to-orange-600 text-white px-10 py-3 rounded-full text-xl font-bold hover:from-yellow-600 hover:to-orange-700 transform hover:scale-105 transition-all"
                >
                  ë‹¤ì‹œ ì‹œì‘
                </button>
              </div>
            </div>
          )}
        </div>

        <div className="mt-4 text-center text-gray-400 text-sm">
          <p>â† â†’ í™”ì‚´í‘œ í‚¤ ë˜ëŠ” ë§ˆìš°ìŠ¤ë¡œ ì¡°ì‘</p>
        </div>
      </div>
    </div>
  );
}